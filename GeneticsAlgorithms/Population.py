'''
    
    This class represents Population of DNA
    Every solution is just a list of Genoms in order
    Order determined the path: from first element of list to last element
    
    
    1.) This class manage selection(pool selection), fitness and crossover

'''

import DNA
import Salesman
import random as r
from tensorflow.python.framework.test_ops import none


#------------------------------------------------------------------------------
def poolSelection(fitnessDict):
    """
        make a list where the best salesmann is most probably and
        the worst most likly to be pick
    """
    listOfSalesman = list()
    fitnessSum = getSummedFitness(dict)
    for key,value in fitnessDict.items():
        pass
#------------------------------------------------------------------------------
def doesNotHaveTheSameDNA(salesman,listOfSalesmen):
    """checks if objects from list dont have the same DNA"""
    returnValue = True
    for man in listOfSalesmen:
        if man == salesman:
            returnValue = False
    return returnValue
#------------------------------------------------------------------------------
class Population:
    def __init__(self,populationSize,listOfPoints):
        """init list of possible Salesman paths"""
        self.salesmanList = list()
        for x in range(0, populationSize):
            # init new DNA and add to list
            self.salesmanList.append(Salesman.Salesman(listOfPoints)) 
        self.summedFitness = self.getSummedFitness()   # because fitness is 1/value sum of fitnes must be also 1/value for selection calculation
 #------------------------------------------------------------------------------      
    def getSummedFitness(self):
        sum = 0
        for x in self.salesmanList:
            sum += x.fitness
        return sum
#------------------------------------------------------------------------------
    def __str__(self):
        """standard python fun for displaying class info"""
        listToJoin = list()
        for x in self.salesmanList:
            listToJoin.append(str(x))
        stringToReturn = '\n'.join(listToJoin)
        stringToReturn +="\n"
        return stringToReturn
#------------------------------------------------------------------------------
    def nextGeneration(self):
        """generates next generation of population"""
        # I want next generation to contain up to 50%
        # of best solution from previous generation and rest generated by crossover
        
        # choose randomly half of next population
        nextPopulation = self.getRandomlyHalf()
        
#         pool = poolSelection(dict)                   # make a list from dict to draw parents to make an offspring
#         for key,value in dict.items():
#             
#------------------------------------------------------------------------------
    def getRandomlyHalf(self):
        """
            return list of size of half of salesmanList with randomly 
            choosen salesmen based on fitness probability
        """
        stop = len(self.salesmanList)/2
        count = 0
        normalizedFitness = 0
        listHalf = list()
        iterList = iter(self.salesmanList)
        while count < stop:
            randomValue = r.uniform(0,1)
            salesman = next(iterList)
            if(round(salesman.fitness*1.0/self.summedFitness*1.0,3) > randomValue):
               listHalf.append(salesman)
               count += 1
            if salesman is self.salesmanList[-1]:
                iterList = iter(self.salesmanList)
        for x in listHalf:
            print("-------------")
            print(x)
#             print(randomValue)
#------------------------------------------------------------------------------
# Tests
# Test _str
p = Population(20,[(0,4),(4,2),(5,2),(0,10),(4,12),(2,0),(12,8)])
# print(p)
# Test countFitnes(x)
# dict = p.countFitnesForPopulation()    
# for x,y in dict.items():
#     print(x)
#     for yy in y:
#         print(y)
p.nextGeneration()
